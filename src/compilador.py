# -*- coding: utf-8 -*-
"""Compilador.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bTSuSTaxsBv-69b-5O7JFfyE_FN20Ewz
"""

import re
import sys

# ================== 1. ANALIZADOR LÉXICO (FINAL) ==================

class AnalizadorLexico:
    def __init__(self):
        self.palabras_reservadas = {
            'int': 'TIPO_INT', 'bool': 'TIPO_BOOL', 'if': 'IF',
            'else': 'ELSE', 'while': 'WHILE', 'print': 'PRINT',
            'true': 'TRUE', 'false': 'FALSE'
        }

        self.mapa_tokens = {
            '&&': 'OP_AND', '||': 'OP_OR',
            '==': 'OP_REL', '!=': 'OP_REL', '<=': 'OP_REL', '>=': 'OP_REL',
            '<': 'OP_REL', '>': 'OP_REL',
            '!': 'OP_NOT',
            '+': 'OP_ARIT', '-': 'OP_ARIT', '*': 'OP_ARIT', '/': 'OP_ARIT',
            '=': 'ASIGN',
            ';': 'PUNTOCOMA', ',': 'COMA',
            '(': 'LPAREN', ')': 'RPAREN',
            '{': 'LBRACE', '}': 'RBRACE'
        }

        # Grupos de no captura (?:...) aplicados para evitar problemas de índice
        rules = [
            (r'\s+', None),
            (r'//.*', None),
            (r'(?:==|<=|>=|!=|&&|\|\|)', 'OPERADOR_MULTI'),
            (r'\b(?:int|bool|if|else|while|print|true|false)\b', 'KEYWORD'),
            (r'\b[0-9]+\b', 'NUMERO_ENTERO'),
            (r'\b[a-zA-Z_][a-zA-Z0-9_]*\b', 'ID'),
            (r'[=<>\+\-\*/!;,(){}]', 'OPERADOR_SIMPLE')
        ]

        self.patron_token = re.compile('|'.join(f'({rule})' for rule, _ in rules))
        self.tipos_token = [tipo for _, tipo in rules]

    def tokenizar(self, codigo):
        tokens = []
        linea = 1

        for match in self.patron_token.finditer(codigo):
            tipo = None
            valor = match.group(0)

            # ********** CORRECCIÓN DEL ÍNDICE APLICADA (i + 1) **********
            for i, tipo_sub in enumerate(self.tipos_token):
                if match.group(i + 1): # <-- CAMBIO CLAVE
                    tipo = tipo_sub
                    break
            # ************************************************************

            if tipo is None:
                if '\n' in valor:
                    linea += valor.count('\n')
                continue

            tipo_token = None
            if tipo == 'KEYWORD':
                tipo_token = self.palabras_reservadas.get(valor)
            elif tipo == 'ID':
                tipo_token = 'ID'
            elif tipo == 'NUMERO_ENTERO':
                tipo_token = 'LITERAL_ENTERO'
            elif tipo == 'OPERADOR_MULTI' or tipo == 'OPERADOR_SIMPLE':
                tipo_token = self.mapa_tokens.get(valor)

            if tipo_token is None:
                print(f"Advertencia Léxica en línea {linea}: Token no reconocido '{valor}' (tipo {tipo}) ignorado.")
                continue

            tokens.append(Token(tipo_token, valor, linea))

        tokens.append(Token('EOF', 'EOF', linea))
        return tokens

class Token:
    def __init__(self, tipo, valor, linea):
        self.tipo = tipo
        self.valor = valor
        self.linea = linea
    def __repr__(self):
        return f"Token({self.tipo}, '{self.valor}')"

# ================== 2. CLASES AST ==================

class ASTNode: pass
class Program(ASTNode):
    def __init__(self, statements):
        self.statements = statements

class Statement(ASTNode): pass
class Expression(ASTNode): pass

class VarDecl(Statement):
    def __init__(self, tipo_token, var_token):
        self.tipo_token = tipo_token
        self.var_token = var_token

class Assignment(Statement):
    def __init__(self, var_token, expression):
        self.var_token = var_token
        self.expression = expression

class IfStatement(Statement):
    def __init__(self, condition, true_branch, false_branch):
        self.condition = condition
        self.true_branch = true_branch
        self.false_branch = false_branch

class WhileStatement(Statement):
    def __init__(self, condition, body):
        self.condition = condition
        self.body = body

class PrintStatement(Statement):
    def __init__(self, expression):
        self.expression = expression

class Block(Statement):
    def __init__(self, statements):
        self.statements = statements

class BinaryOp(Expression):
    def __init__(self, left, op_token, right):
        self.left = left
        self.op_token = op_token
        self.right = right

class UnaryOp(Expression):
    def __init__(self, op_token, right):
        self.op_token = op_token
        self.right = right

class Literal(Expression):
    def __init__(self, token):
        self.token = token

class Variable(Expression):
    def __init__(self, token):
        self.token = token

# ================== 3. ANALIZADOR SINTÁCTICO ==================

class AnalizadorSintactico:
    def __init__(self, tokens):
        self.tokens = tokens
        self.pos = 0
        self.token_actual = self.tokens[self.pos]

    def _error(self, mensaje):
        print(f"Error Sintáctico en línea {self.token_actual.linea}: {mensaje}. Se encontró: {self.token_actual.tipo}")
        sys.exit(1) # Termina el programa

    def _avanzar(self):
        self.pos += 1
        if self.pos < len(self.tokens):
            self.token_actual = self.tokens[self.pos]

    def _consumir(self, tipo_esperado):
        if self.token_actual.tipo == tipo_esperado:
            self._avanzar()
        else:
            self._error(f"Se esperaba '{tipo_esperado}'")

    def parse(self):
        statements = []
        while self.token_actual.tipo != 'EOF':
            statements.append(self.parse_statement())
        return Program(statements)

    def parse_statement(self):
        if self.token_actual.tipo in ('TIPO_INT', 'TIPO_BOOL'):
            return self.parse_var_declaration()
        elif self.token_actual.tipo == 'IF':
            return self.parse_if_statement()
        elif self.token_actual.tipo == 'WHILE':
            return self.parse_while_statement()
        elif self.token_actual.tipo == 'PRINT':
            return self.parse_print_statement()
        elif self.token_actual.tipo == 'ID':
            return self.parse_assignment_statement()
        elif self.token_actual.tipo == 'LBRACE':
            return self.parse_block()
        else:
            self._error("Declaración no válida")

    def parse_block(self):
        statements = []
        self._consumir('LBRACE')
        while self.token_actual.tipo != 'RBRACE' and self.token_actual.tipo != 'EOF':
            statements.append(self.parse_statement())
        self._consumir('RBRACE')
        return Block(statements)

    def parse_var_declaration(self):
        tipo_token = self.token_actual
        self._avanzar()
        var_token = self.token_actual
        self._consumir('ID')
        self._consumir('PUNTOCOMA')
        return VarDecl(tipo_token, var_token)

    def parse_assignment_statement(self):
        var_token = self.token_actual
        self._consumir('ID')
        self._consumir('ASIGN')
        expr = self.parse_expression()
        self._consumir('PUNTOCOMA')
        return Assignment(var_token, expr)

    def parse_if_statement(self):
        self._consumir('IF')
        self._consumir('LPAREN')
        condicion = self.parse_expression()
        self._consumir('RPAREN')
        true_branch = self.parse_statement()

        false_branch = None
        if self.token_actual.tipo == 'ELSE':
            self._avanzar()
            false_branch = self.parse_statement()

        return IfStatement(condicion, true_branch, false_branch)

    def parse_while_statement(self):
        self._consumir('WHILE')
        self._consumir('LPAREN')
        condicion = self.parse_expression()
        self._consumir('RPAREN')
        body = self.parse_statement()
        return WhileStatement(condicion, body)

    def parse_print_statement(self):
        self._consumir('PRINT')
        self._consumir('LPAREN')
        expr = self.parse_expression()
        self._consumir('RPAREN')
        self._consumir('PUNTOCOMA')
        return PrintStatement(expr)

    def parse_expression(self):
        nodo = self.parse_primary_expression()
        while self.token_actual.tipo in ('OP_ARIT', 'OP_REL', 'OP_AND', 'OP_OR'):
            op_token = self.token_actual
            self._avanzar()
            right = self.parse_primary_expression()
            nodo = BinaryOp(left=nodo, op_token=op_token, right=right)
        return nodo

    def parse_primary_expression(self):
        token = self.token_actual
        if token.tipo == 'LITERAL_ENTERO':
            self._avanzar()
            return Literal(token)
        elif token.tipo in ('TRUE', 'FALSE'):
            self._avanzar()
            return Literal(token)
        elif token.tipo == 'ID':
            self._avanzar()
            return Variable(token)
        elif token.tipo == 'LPAREN':
            self._avanzar()
            nodo = self.parse_expression()
            self._consumir('RPAREN')
            return nodo
        else:
            self._error("Expresión primaria no válida (se esperaba número, ID, 'true'/'false' o '(')")

# ================== 4. STUBS (SIMULACROS)  ==================

class AnalizadorSemanticoAST:
    # Finge ser el Analizador Semántico. Acepta el AST.
    def __init__(self):
        print("[STUB Semántico] Iniciado (Modo AST).")
        self.tabla_simbolos = {}

    def analizar(self, ast_node):
        if not isinstance(ast_node, Program):
             print(f"[STUB Semántico] Error: Se esperaba un nodo 'Program', se recibió {type(ast_node)}")
             return
        print("[STUB Semántico] 'Analizando' el nodo raíz del AST (Program)...")
        print("[STUB Semántico] Análisis simulado completado (sin errores).")
        pass

class TACGenerator:
    def __init__(self):
        self.temp_counter = 0
        self.label_counter = 0
        self.instructions = []
    # Los temp sirven para las variables temporales donde se guarda la informacion de operaciones binarias
    def new_temp(self):
    # Genera un nuevo nombre de temporal
        self.temp_counter += 1
        return f"t{self.temp_counter}"

    # Las etiquetas indican saltos de linea y cambian el flujo del código
    def new_label(self):
        #Genera una nueva etiqueta
        self.label_counter += 1
        return f"L{self.label_counter}"

    def emit(self, instruction):
        #Añade una instrucción TAC a la lista
        self.instructions.append(instruction)

    def visit(self, node):
        #Método principal que visita cada tipo de nodo
        method_name = f'visit_{type(node).__name__}' # Busca el método del tipo que reciba
        method = getattr(self, method_name, self.visit_unknown) # Ejecuta su método dependiendo del tipo
        return method(node)

    def visit_unknown(self, node):
        raise Exception(f"Método visit no implementado para {type(node).__name__}")

    # ========== MÉTODOS del AST ==========

    def visit_Program(self, node):
        for statement in node.statements:
            self.visit(statement)

    # Para valores enteros
    def visit_Literal(self, node):
        return node.token.valor
    # Para variables
    def visit_Variable(self, node):
        return node.token.valor

    # Para operaciones binarias
    def visit_BinaryOp(self, node):
        # Visita primero sus nodos hijos
        left_value = self.visit(node.left)
        right_value = self.visit(node.right)
        temp = self.new_temp() # obtiene una variable temporal para luego almacenarla
        self.emit(f"{temp} := {left_value} {node.op_token.valor} {right_value}")
        return temp
    # Para asignación x = a + b
    def visit_Assignment(self, node):
        # Checa el target (x)
        target = node.var_token.valor
        # Checa el valor de la asignación (a + b)
        value = self.visit(node.expression)
        self.emit(f"{target} := {value}")
        return target
    # Para ifs
    def visit_IfStatement(self, node):
        # Visita primero la condición
        condition = self.visit(node.condition)
        # Declara label del else, importante para marcar el flujo
        label_else = self.new_label()


        self.emit(f"if {condition} == false goto {label_else}")
        #Visita la condición que se cumple
        self.visit(node.true_branch)

        if node.false_branch:# Si hay sentencia de else no vacía
            label_end = self.new_label() # Declara nuevo label para el salto al final de la condición
            self.emit(f"goto {label_end}")
            self.emit(f"{label_else}:") # Inicio del bloque else
            self.visit(node.false_branch)
            self.emit(f"{label_end}:")
        else:
            self.emit(f"{label_else}:")

    # Para el while
    def visit_WhileStatement(self, node):
        # Declaración de labels primero para el flujo de información
        label_start = self.new_label()
        label_end = self.new_label()

        self.emit(f"{label_start}:")
        # Procesar la condición
        condition = self.visit(node.condition)
        self.emit(f"if {condition} == false goto {label_end}")
        # Visitar el contenido del while
        self.visit(node.body)
        self.emit(f"goto {label_start}")
        self.emit(f"{label_end}:")

    # Para los bloques de código extensos (de if y while)
    def visit_Block(self, node):
        # Por cada uno de las lineas de código, se visitan
        for statement in node.statements:
            self.visit(statement)

    # Para el print
    def visit_PrintStatement(self, node):
        value = self.visit(node.expression)
        self.emit(f"print {value}")

    def visit_VarDecl(self, node):
        # Las declaraciones no generan código TAC ejecutable
        self.emit(f"# Declaración: {node.tipo_token.valor} {node.var_token.valor}")

    def generate(self, ast):
        self.instructions = []
        self.temp_counter = 0
        self.label_counter = 0
        self.visit(ast)
        return self.instructions

class GeneradorDeCodigo:
    def __init__(self):
        print("[CodeGen] Iniciado (Generador TAC Real).")
        self.generator = TACGenerator()

    def generar(self, ast_node):
        print("[CodeGen] Generando TAC desde el AST...")
        instructions = self.generator.generate(ast_node)

        # Convertir a string para guardar en archivo
        tac_code = "\n".join(instructions)
        return tac_code

# Máquina TAC
class MaquinaTAC:
    def __init__(self):
        print("[MaquinaTAC] VM Inicializada.")
        self.mem = {}  # Memoria de variables y temporales
        self.labels = {} # Mapa de etiquetas a número de línea

    def _get_val(self, operando):
        if operando.isdigit():
            return int(operando)
        elif operando == 'true':
            return True
        elif operando == 'false':
            return False
        return self.mem.get(operando, 0)

    def preprocesar_etiquetas(self, lineas):
        """Busca donde están las etiquetas para los saltos"""
        self.labels.clear()
        instrucciones_limpias = []
        indice = 0
        for linea in lineas:
            linea = linea.strip()
            if not linea or linea.startswith('#'): continue

            if linea.endswith(':'): # Es una etiqueta
                label_name = linea[:-1]
                self.labels[label_name] = indice
            else:
                instrucciones_limpias.append(linea)
                indice += 1
        return instrucciones_limpias

    def ejecutar(self, codigo_tac_string):
        lineas_crudas = codigo_tac_string.split('\n')
        instrucciones = self.preprocesar_etiquetas(lineas_crudas)
        pc = 0 # Program Counter

        print(f"\n--- [Ejecución Real] Iniciando ({len(instrucciones)} instrucciones) ---")

        while pc < len(instrucciones):
            inst = instrucciones[pc]
            partes = inst.split()

            # 1. Saltos (GOTO)
            if partes[0] == 'goto':
                etiqueta = partes[1]
                pc = self.labels[etiqueta]
                continue

            # 2. IF (if t1 == false goto L2)
            elif partes[0] == 'if':
                cond_val = self._get_val(partes[1])
                target_val = False
                label = partes[5]
                if cond_val == target_val:
                    pc = self.labels[label]
                    continue

            # 3. PRINT
            elif partes[0] == 'print':
                val = self._get_val(partes[1])
                print(f"OUTPUT >> {val}")

            # 4. Asignaciones y Operaciones
            elif len(partes) >= 3 and partes[1] == ':=':
                destino = partes[0]

                if len(partes) == 3: # x := 5
                    self.mem[destino] = self._get_val(partes[2])

                elif len(partes) == 5: # t1 := a + b
                    op1 = self._get_val(partes[2])
                    operador = partes[3]
                    op2 = self._get_val(partes[4])

                    res = 0
                    if operador == '+': res = op1 + op2
                    elif operador == '-': res = op1 - op2
                    elif operador == '*': res = op1 * op2
                    elif operador == '/': res = int(op1 / op2)
                    elif operador == '<': res = op1 < op2
                    elif operador == '>': res = op1 > op2
                    elif operador == '==': res = (op1 == op2)
                    elif operador == '!=': res = (op1 != op2)
                    elif operador == '&&': res = (op1 and op2)
                    elif operador == '||': res = (op1 or op2)

                    self.mem[destino] = res

            pc += 1
        print("--- [Ejecución Real] Finalizada ---")

# ================== 5. PIPELINE ==================

def compilar(ruta_archivo_fuente, ruta_archivo_salida):

    # 0. Instanciar componentes
    lexico = AnalizadorLexico()
    semantico = AnalizadorSemanticoAST() # El STUB
    generador_tac = GeneradorDeCodigo() # El STUB

    print(f"--- Iniciando compilacion de: {ruta_archivo_fuente} ---")

    # 1. Leer el código fuente COMPLETO
    try:
        with open(ruta_archivo_fuente, 'r', encoding='utf-8') as file:
            codigo_completo = file.read()
    except FileNotFoundError:
        print(f"Error: No se encontro el archivo '{ruta_archivo_fuente}'")
        return False

    # --- ETAPA 1: LÉXICO ---
    print("\n--- ETAPA 1: LEXICO ---")
    tokens = lexico.tokenizar(codigo_completo)
    print(f"Tokens generados: {len(tokens)}")

    # --- ETAPA 2: SINTÁCTICO (Parser) ---
    print("\n--- ETAPA 2: SINTACTICO (Parser) ---")
    try:
        parser = AnalizadorSintactico(tokens)
        ast = parser.parse()
        print("Arbol de Sintaxis Abstracto (AST) generado exitosamente.")
    except SystemExit:
        print("Compilación detenida por error sintactico.")
        return False
    except Exception as e:
        print(f"Error Sintáctico Fatal Inesperado: {e}")
        return False

    # --- ETAPA 3: SEMÁNTICO ---
    print("\n--- ETAPA 3: SEMÁNTICO ---")
    semantico.analizar(ast) # Llama al STUB
    print("Analisis semántico simulado completado.")

    # --- ETAPA 4: GENERACIÓN DE CÓDIGO (TAC) ---
    print("\n--- ETAPA 4: GENERACIÓN DE CODIGO (TAC) ---")
    codigo_tac = generador_tac.generar(ast) # Llama al STUB
    print("Codigo TAC simulado generado exitosamente.")

    with open(ruta_archivo_salida, "w", encoding='utf-8') as f:
        f.write(codigo_tac)
    print(f"Codigo TAC guardado en: {ruta_archivo_salida}")

    print("\n--- Compilacion Finalizada Exitosamente ---")
    return True


def ejecutar(ruta_archivo_tac, maquina_tac_real):
    print(f"\n--- ETAPA 5: EJECUCIÓN (Runtime) ---")

    try:
        with open(ruta_archivo_tac, 'r') as f:
            contenido_tac = f.read()
            print(f"Contenido de {ruta_archivo_tac} a ejecutar:\n{contenido_tac}")

            # CORRECCIÓN: Pasamos el string real, no la lista falsa
            maquina_tac_real.ejecutar(contenido_tac)

    except FileNotFoundError:
        print(f"Error: No se encontró el archivo TAC '{ruta_archivo_tac}'")

# Commented out IPython magic to ensure Python compatibility.
# %%writefile ejemplo.txt
# // Archivo de prueba para el compilador
# 
# int x;
# int y;
# 
# x = 10;
# y = 5;
# 
# print(x);
# 
# if (x > y) {
#     print(1);
# } else {
#     print(0);
# }
# 
# while (x > 0) {
#     x = x - 1;
# }

# ================== 7. PUNTO DE ENTRADA ==================

if __name__ == "__main__":
    print("========================================")
    print("    Bienvenido al Mini-Language Compiler")
    print("========================================")
    print("Selecciona una opción:")
    print("1) Cargar archivo .txt desde ruta")
    print("2) Ejecutar la demo (ejemplo.txt)")
    print("========================================")

    opcion = input("Ingresa 1 o 2: ").strip()

    # Opción 1 → usuario le da la ruta del archivo
    if opcion == "1":
        ruta_usuario = input("Escribe la ruta del archivo .txt a compilar: ").strip()

        if ruta_usuario == "":
            print("Ruta vacía. Cancelando.")
            sys.exit(1)

        print(f"\nCompilando archivo: {ruta_usuario}\n")
        archivo_fuente = ruta_usuario
        archivo_tac_salida = "output.tac"

        exito = compilar(archivo_fuente, archivo_tac_salida)
        if exito:
            vm_real = MaquinaTAC()
            ejecutar(archivo_tac_salida, vm_real)
        else:
            print("\nError: la compilación falló.")
            sys.exit(1)

    # Opción 2 → usar ejemplo.txt
    elif opcion == "2":
        print("\nUsando archivo de demostración: ejemplo.txt\n")

        archivo_fuente = "ejemplo.txt"
        archivo_tac_salida = "output.tac"

        exito = compilar(archivo_fuente, archivo_tac_salida)
        if exito:
            vm_real = MaquinaTAC()
            ejecutar(archivo_tac_salida, vm_real)
        else:
            print("\nError: la compilación falló.")
            sys.exit(1)

    else:
        print("Opción inválida. Debes ingresar 1 o 2.")
        sys.exit(1)