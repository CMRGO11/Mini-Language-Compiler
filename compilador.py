# -*- coding: utf-8 -*-
"""Compilador.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bTSuSTaxsBv-69b-5O7JFfyE_FN20Ewz
"""
# En compilador.py - MUEVE esta línea ARRIBA de los imports
import argparse
import re
from src.lexer import AnalizadorLexico
from src.parser import AnalizadorSintactico
from src.semantic import AnalizadorSemanticoAST
from src.tac_generator import GeneradorDeCodigo
from src.vm import MaquinaTAC
import sys
import os

# Añadir src al path para imports
sys.path.append(os.path.join(os.path.dirname(__file__), 'src'))

# Elimina las líneas duplicadas (líneas 49-53 aproximadamente)


# ================== PIPELINE ==================


def compilar(ruta_archivo_fuente, ruta_archivo_salida):

    # 0. Instanciar componentes
    lexico = AnalizadorLexico()
    semantico = AnalizadorSemanticoAST()  # El STUB
    generador_tac = GeneradorDeCodigo()  # El STUB

    print(f"--- Iniciando compilacion de: {ruta_archivo_fuente} ---")

    # 1. Leer el código fuente COMPLETO
    try:
        with open(ruta_archivo_fuente, 'r', encoding='utf-8') as file:
            codigo_completo = file.read()
    except FileNotFoundError:
        print(f"Error: No se encontro el archivo '{ruta_archivo_fuente}'")
        return False

    # --- ETAPA 1: LÉXICO ---
    print("\n--- ETAPA 1: LEXICO ---")
    tokens = lexico.tokenizar(codigo_completo)
    print(f"Tokens generados: {len(tokens)}")

    # --- ETAPA 2: SINTÁCTICO (Parser) ---
    print("\n--- ETAPA 2: SINTACTICO (Parser) ---")
    try:
        parser = AnalizadorSintactico(tokens)
        ast = parser.parse()
        print("Arbol de Sintaxis Abstracto (AST) generado exitosamente.")
    except SystemExit:
        print("Compilación detenida por error sintactico.")
        return False
    except Exception as e:
        print(f"Error Sintáctico Fatal Inesperado: {e}")
        return False

    # --- ETAPA 3: SEMÁNTICO ---
    print("\n--- ETAPA 3: SEMÁNTICO ---")
    semantico.analizar(ast)  # Llama al STUB
    print("Analisis semántico simulado completado.")

    # --- ETAPA 4: GENERACIÓN DE CÓDIGO (TAC) ---
    print("\n--- ETAPA 4: GENERACIÓN DE CODIGO (TAC) ---")
    codigo_tac = generador_tac.generar(ast)  # Llama al STUB
    print("Codigo TAC simulado generado exitosamente.")

    with open(ruta_archivo_salida, "w", encoding='utf-8') as f:
        f.write(codigo_tac)
    print(f"Codigo TAC guardado en: {ruta_archivo_salida}")

    print("\n--- Compilacion Finalizada Exitosamente ---")
    return True


def ejecutar(ruta_archivo_tac, maquina_tac_real):
    print(f"\n--- ETAPA 5: EJECUCIÓN (Runtime) ---")

    try:
        with open(ruta_archivo_tac, 'r') as f:
            contenido_tac = f.read()
            print(
                f"Contenido de {ruta_archivo_tac} a ejecutar:\n{contenido_tac}")

            # CORRECCIÓN: Pasamos el string real, no la lista falsa
            maquina_tac_real.ejecutar(contenido_tac)

    except FileNotFoundError:
        print(f"Error: No se encontró el archivo TAC '{ruta_archivo_tac}'")

# ================== PUNTO DE ENTRADA ==================


# ================== SISTEMA DE COMANDOS CLI ==================
#!/usr/bin/env python3
"""
Punto de entrada principal del compilador
"""

# Añadir src al path para imports
sys.path.append(os.path.join(os.path.dirname(__file__), 'src'))


def parse_arguments():
    """Configura y parsea los argumentos de línea de comandos"""
    parser = argparse.ArgumentParser(
        description='Mini-Language Compiler - De código fuente a TAC ejecutable',
        epilog='Ejemplos:\n  python compilador.py compile ejemplo.txt -o output.tac\n  python compilador.py run output.tac\n  python compilador.py compile ejemplo.txt --run',
        formatter_class=argparse.RawDescriptionHelpFormatter
    )

    subparsers = parser.add_subparsers(
        dest='comando', help='Comando a ejecutar')

    # Comando COMPILE
    compile_parser = subparsers.add_parser(
        'compile', help='Compilar archivo fuente a TAC')
    compile_parser.add_argument(
        'archivo_fuente', help='Archivo .src o .txt a compilar')
    compile_parser.add_argument('-o', '--output', default='output.tac',
                                help='Archivo de salida TAC (default: output.tac)')
    compile_parser.add_argument('--run', action='store_true',
                                help='Ejecutar automáticamente después de compilar')

    # Comando RUN
    run_parser = subparsers.add_parser('run', help='Ejecutar archivo TAC')
    run_parser.add_argument('archivo_tac', help='Archivo .tac a ejecutar')

    return parser.parse_args()


def modo_interactivo():
    """Mantiene el modo interactivo al ejecutarse"""
    print("========================================")
    print("    Bienvenido al Mini-Language Compiler")
    print("========================================")
    print("Selecciona una opción:")
    print("1) Cargar archivo .txt desde ruta")
    print("2) Ejecutar la demo (ejemplo.txt)")
    print("========================================")

    opcion = input("Ingresa 1 o 2: ").strip()

    if opcion == "1":
        ruta_usuario = input(
            "Escribe la ruta del archivo .txt a compilar: ").strip()
        if not ruta_usuario:
            print("Ruta vacía. Cancelando.")
            sys.exit(1)

        archivo_fuente = ruta_usuario
        archivo_tac_salida = "output.tac"

        exito = compilar(archivo_fuente, archivo_tac_salida)
        if exito:
            vm_real = MaquinaTAC()
            ejecutar(archivo_tac_salida, vm_real)
        else:
            print("\nError: la compilación falló.")
            sys.exit(1)

    elif opcion == "2":
        archivo_fuente = "ejemplo.txt"
        archivo_tac_salida = "output.tac"

        exito = compilar(archivo_fuente, archivo_tac_salida)
        if exito:
            vm_real = MaquinaTAC()
            ejecutar(archivo_tac_salida, vm_real)
        else:
            print("\nError: la compilación falló.")
            sys.exit(1)
    else:
        print("Opción inválida. Debes ingresar 1 o 2.")
        sys.exit(1)


def ejecutar_comando_cli(args):
    """Ejecuta los comandos de línea de comandos"""
    if args.comando == 'compile':
        print(f"Compilando {args.archivo_fuente} -> {args.output}")

        if not os.path.exists(args.archivo_fuente):
            print(f"Error: Archivo {args.archivo_fuente} no encontrado")
            sys.exit(1)

        exito = compilar(args.archivo_fuente, args.output)

        if exito and args.run:
            print("Ejecutando código TAC...")
            vm = MaquinaTAC()
            ejecutar(args.output, vm)

    elif args.comando == 'run':
        print(f"Ejecutando {args.archivo_tac}")

        if not os.path.exists(args.archivo_tac):
            print(f"Error: Archivo TAC {args.archivo_tac} no encontrado")
            sys.exit(1)

        vm = MaquinaTAC()
        ejecutar(args.archivo_tac, vm)


if __name__ == "__main__":
    # Verificar si se pasaron argumentos por CLI
    if len(sys.argv) > 1:
        # Modo CLI con compile
        args = parse_arguments()
        if args.comando:
            ejecutar_comando_cli(args)
        else:
            print("Comando no reconocido. Usa 'compile' o 'run'")
            sys.exit(1)
    else:
        # Modo interactivo (compatibilidad hacia atrás)
        modo_interactivo()
